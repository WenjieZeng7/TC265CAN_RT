/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Platform_Types.h"
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"

#include "SysSe/Bsp/Bsp.h"   //???????????????????????
#include "Port/Io/IfxPort_Io.h"
#include "Multican/Can/IfxMultican_Can.h"       //????CAN????API
#include "Flash_Programming.h"


IfxCpu_syncEvent g_cpuSyncEvent = 0;

//????CAN??Óî???MessageObject??
// CAN handle
IfxMultican_Can can;
// Nodes handles
IfxMultican_Can_Node canSrcNode;
// Message Object handles
IfxMultican_Can_MsgObj canSrcMsgObj;
IfxMultican_Can_MsgObj canRcvMsgObj;
IfxMultican_Can_MsgObj canRcvMsgObj2;

void CAN_SendSingle(uint32 id, uint32 high, uint32 low);

//?????ßÿ??????ßÿ???? ???????????????ßÿ? ???LED???
#define ISR_PRIORITY_CAN_RX         1                           /* Define the CAN RX interrupt priority              */
#define ISR_PRIORITY_CAN_TX         2                           /* Define the CAN TX interrupt priority              */
#define ISR_PRIORITY_CAN_RX_2       3                           /* Define the CAN RX interrupt priority              */

#define TX_INTERRUPT_SRC_ID         IfxMultican_SrcId_0         /* Transmit interrupt service request ID             */
#define RX_INTERRUPT_SRC_ID         IfxMultican_SrcId_1         /* Receive interrupt service request ID              */
#define RX_INTERRUPT_SRC_ID_2       IfxMultican_SrcId_2         /* Receive interrupt service request ID              */
IFX_INTERRUPT(canIsrTxHandler, 0, ISR_PRIORITY_CAN_TX);
IFX_INTERRUPT(canIsrRxHandler, 0, ISR_PRIORITY_CAN_RX);
IFX_INTERRUPT(canIsrRxHandler_2, 0, ISR_PRIORITY_CAN_RX_2);

//??????????ISO 11992????


#define MEM(address)                *((uint32 *)(address))      /* Macro to simplify the access to a memory address */
#define DFLASH_STARTING_ADDRESS     0xAF000000                  /* Address of the DFLASH where the data is written  */


void canIsrRxHandler_2(void)
{
    IfxMultican_Message txMsg;
    IfxMultican_Can_MsgObj_readMessage(&canRcvMsgObj2,&txMsg);  //??MO?????????
    int ids;
    if(txMsg.id==0x12345678)//????????
    {
//        id1=txMsg.data[0] & 0xFF; //????¶À??8bit
//        id2=txMsg.data[0]>>8 & 0xFF;  //???????9¶À????16¶À
//        if(id1==0x78 && id2==0x56) IfxPort_togglePin(&MODULE_P33, 9);

//        ids=txMsg.data[0] & 0xFFFFFF;
//        if(ids==0x345678) IfxPort_togglePin(&MODULE_P33, 9);

        //3?????????ISO 11992?????????????-???1-???2?????ß’??????????6Bytes??
        //?????????????????ID?0x12345678?????????????0x0020c8c0??0x00000000
        ids=txMsg.data[0];
        writeDataFlash(ids);
    }
    int getid;
    getid = MEM(DFLASH_STARTING_ADDRESS);
    //??????????
//    if(getid==0x0020c8c0)
//    {
//        IfxPort_togglePin(&MODULE_P33, 9);
//    }
//    else
//    {
//        IfxPort_togglePin(&MODULE_P33, 8);
//    }
    int id1,id2,id3;
    id3 = getid & 0xFF;
    id2 = getid>>8 & 0xFF;
    id1 = getid>>16 & 0xFF;
    if(id1 == 0x20 && id2 == 0xc8 && id3 == 0xc0) IfxPort_togglePin(&MODULE_P33, 9);
}


#define WAIT_TIME 500   /* Wait time constant in milliseconds   */

//?????ßÿ???????? ???LED1
void canIsrTxHandler(void)
{
    IfxPort_togglePin(&MODULE_P33, 8);
}

//?????ßÿ???????? ????LED2
void canIsrRxHandler(void)
{
    IfxPort_togglePin(&MODULE_P33, 9);
    IfxMultican_Status readStatus;      //??CAN??¶À

    IfxMultican_Message rxMsg;          //???????????? ??ID ??????? ????

    /* Read the received CAN message and store the status of the operation */
    readStatus = IfxMultican_Can_MsgObj_readMessage(&canRcvMsgObj, &rxMsg);     //????????CAN??????õ•??????

    /* If no new data has been received, report an error */
    if( !( readStatus & IfxMultican_Status_newData ) )
    {
        while(1)
        {
        }
    }

    /* If new data has been received but with one message lost, report an error */
    if( readStatus == IfxMultican_Status_newDataButOneLost )
    {
        while(1)
        {
        }
    }

    CAN_SendSingle(0x12345200, rxMsg.data[0], rxMsg.data[1]);        //????????????????ID?0x12345200?????????????

}

void CanApp_init(void)
{
    // create configuration
    IfxMultican_Can_Config canConfig;
    IfxMultican_Can_initModuleConfig(&canConfig, &MODULE_CAN);
    // initialize interrupt priority
    canConfig.nodePointer[TX_INTERRUPT_SRC_ID].priority = ISR_PRIORITY_CAN_TX;
    canConfig.nodePointer[RX_INTERRUPT_SRC_ID].priority = ISR_PRIORITY_CAN_RX;      //?????ßÿ???
    canConfig.nodePointer[RX_INTERRUPT_SRC_ID_2].priority = ISR_PRIORITY_CAN_RX_2;      //?????ßÿ???
    // initialize module
    IfxMultican_Can_initModule(&can, &canConfig);

    // create CAN node config
    IfxMultican_Can_NodeConfig canNodeConfig;
    IfxMultican_Can_Node_initConfig(&canNodeConfig, &can);
    canNodeConfig.baudrate = 125000; //
    canNodeConfig.nodeId = IfxMultican_NodeId_0;
    canNodeConfig.rxPin = &IfxMultican_RXD0B_P20_7_IN;      //????????
    canNodeConfig.txPin = &IfxMultican_TXD0_P20_8_OUT;
    IfxMultican_Can_Node_init(&canSrcNode, &canNodeConfig);

    // create message object config
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &canSrcNode);
    // assigned message object:
    canMsgObjConfig.msgObjId = 0;
    canMsgObjConfig.frame = IfxMultican_Frame_transmit;
    canMsgObjConfig.control.messageLen = IfxMultican_DataLengthCode_8;
    canMsgObjConfig.control.extendedFrame = TRUE;
    canMsgObjConfig.txInterrupt.enabled = TRUE;     //???????ßÿ?
    canMsgObjConfig.txInterrupt.srcId = TX_INTERRUPT_SRC_ID;    //?????ßÿ??
    // initialize receive message object
    IfxMultican_Can_MsgObj_init(&canSrcMsgObj, &canMsgObjConfig);

    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &canSrcNode);
    canMsgObjConfig.msgObjId = 1;
    canMsgObjConfig.messageId = 0x12345100;      //???çö???ßÿ??ID
    canMsgObjConfig.acceptanceMask = 0xFFFFFFFF;
    //canMsgObjConfig.acceptanceMask = 0x7FFFFFFFUL;  //??????????????????????
    canMsgObjConfig.frame = IfxMultican_Frame_receive;
    canMsgObjConfig.control.messageLen = IfxMultican_DataLengthCode_8;
    canMsgObjConfig.control.extendedFrame = TRUE;
    canMsgObjConfig.rxInterrupt.enabled = TRUE;     //???????ßÿ?
    canMsgObjConfig.rxInterrupt.srcId = RX_INTERRUPT_SRC_ID;    //?????ßÿ??
    // initialize message object
    IfxMultican_Can_MsgObj_init(&canRcvMsgObj, &canMsgObjConfig);

    //??????ID????MO
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &canSrcNode);
    canMsgObjConfig.msgObjId = 2;
    canMsgObjConfig.messageId = 0x12345678;      //???çö???ßÿ??ID
    canMsgObjConfig.acceptanceMask = 0xFFFFFFFF;
    //canMsgObjConfig.acceptanceMask = 0x7FFFFFFFUL;  //??????????????????????
    canMsgObjConfig.frame = IfxMultican_Frame_receive;
    canMsgObjConfig.control.messageLen = IfxMultican_DataLengthCode_8;
    canMsgObjConfig.control.extendedFrame = TRUE;
    canMsgObjConfig.rxInterrupt.enabled = TRUE;     //???????ßÿ?
    canMsgObjConfig.rxInterrupt.srcId = RX_INTERRUPT_SRC_ID_2;    //?????ßÿ??
    // initialize message object
    IfxMultican_Can_MsgObj_init(&canRcvMsgObj2, &canMsgObjConfig);
}

//CAN???????
void CAN_SendSingle(uint32 id, uint32 high, uint32 low)
{
    // Initialize the message structure
    IfxMultican_Message txMsg;
    IfxMultican_Message_init(&txMsg, id, low, high, IfxMultican_DataLengthCode_8);

    // Transmit Data
    while( IfxMultican_Can_MsgObj_sendMessage(&canSrcMsgObj, &txMsg) == IfxMultican_Status_notSentBusy );

}

/*global varialbe related to remotelock controller */
struct AuthInfo {
    uint64 indentification;
    uint64 startTimestamp;
    uint64 endTime;
};

struct BackEndInfo {
    struct AuthInfo authInfo[10];
    int remoteLockControl;
};

struct UploadMessage {
    uint64 canRoute1;
    uint64 canRoute2;
    uint32 canID1;
    uint32 canID2;
    int lockState;
    int send;
} uploadMessage;

/*
@currentTime variable address passed in, used to store the current time;
@return 0 means success, 1 means failure
*/
int GetCurrentTime(uint64* currentTime)
{

}

int core0_main(void)
{
    struct AuthInfo authInfo[10];
    struct BackEndInfo backEndInfo;
    uint64 ICCode;
    uint64 currentTime;
    int LockStatus;
    int LockControl;
    int ret;
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    initTime();

    //LED
    IfxPort_setPinMode(&MODULE_P33, 8, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(&MODULE_P33, 9, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinHigh(&MODULE_P33, 8);
    IfxPort_setPinLow(&MODULE_P33, 9);


    CanApp_init();

    /*can usart rte initialization, read from the flash to get the AuthInfo structure*/




    
    while(1)
    {
//        CAN_SendSingle(0x01234567,0x5678,0x1234);   //µÕŒª ∏ﬂŒª
// //
//        waitTime(IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME));    /* Wait 500 milliseconds            */
//        IfxPort_togglePin(&MODULE_P33, 8);
    /*1. get the current time zeng*/
    ret = GetCurrentTime(&currentTime);
    if(ret)
    {
        while(1);
    }
    /*2. authenticate if the driver can use the car to determine the desiring lock state*/
    /*3. send can message to the electric control module that indicate whether the lock should be open or on*/ 
    /*4. read usart port for message from the 4G module, fill in the struct backEndInfo zeng*/
    /*5. send the struct UploadMessage to the cloud according to the send value */
    /*6. compare AuthInfo and BackEndInfo, update AuthInfo and dflash if they are not equal*/
    }
    return (1);
}
