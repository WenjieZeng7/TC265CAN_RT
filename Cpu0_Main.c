/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"

#include "SysSe/Bsp/Bsp.h"   //包含时钟相关，延迟函数在此实现
#include "Port/Io/IfxPort_Io.h"
#include "Multican/Can/IfxMultican_Can.h"       //包含CAN控制API
#include "Flash_Programming.h"

IfxCpu_syncEvent g_cpuSyncEvent = 0;

//定义CAN模块、节点、MessageObject：
// CAN handle
IfxMultican_Can can;
// Nodes handles
IfxMultican_Can_Node canSrcNode;
// Message Object handles
IfxMultican_Can_MsgObj canSrcMsgObj;
IfxMultican_Can_MsgObj canRcvMsgObj;
IfxMultican_Can_MsgObj canRcvMsgObj2;

void CAN_SendSingle(uint32 id, uint32 high, uint32 low);

//定义中断等级和中断函数 报文发送完成后进入中断 翻转LED电平
#define ISR_PRIORITY_CAN_RX         1                           /* Define the CAN RX interrupt priority              */
#define ISR_PRIORITY_CAN_TX         2                           /* Define the CAN TX interrupt priority              */
#define ISR_PRIORITY_CAN_RX_2       3                           /* Define the CAN RX interrupt priority              */

#define TX_INTERRUPT_SRC_ID         IfxMultican_SrcId_0         /* Transmit interrupt service request ID             */
#define RX_INTERRUPT_SRC_ID         IfxMultican_SrcId_1         /* Receive interrupt service request ID              */
#define RX_INTERRUPT_SRC_ID_2       IfxMultican_SrcId_2         /* Receive interrupt service request ID              */
IFX_INTERRUPT(canIsrTxHandler, 0, ISR_PRIORITY_CAN_TX);
IFX_INTERRUPT(canIsrRxHandler, 0, ISR_PRIORITY_CAN_RX);
IFX_INTERRUPT(canIsrRxHandler_2, 0, ISR_PRIORITY_CAN_RX_2);

//每个节点对应的ISO 11992的地址


#define MEM(address)                *((uint32 *)(address))      /* Macro to simplify the access to a memory address */
#define DFLASH_STARTING_ADDRESS     0xAF000000                  /* Address of the DFLASH where the data is written  */


void canIsrRxHandler_2(void)
{
    IfxMultican_Message txMsg;
    IfxMultican_Can_MsgObj_readMessage(&canRcvMsgObj2,&txMsg);  //从MO中提取数据
    int ids;
    if(txMsg.id==0x12345678)//已测试可行
    {
//        id1=txMsg.data[0] & 0xFF; //取最低位的8bit
//        id2=txMsg.data[0]>>8 & 0xFF;  //取倒数第9位到第16位
//        if(id1==0x78 && id2==0x56) IfxPort_togglePin(&MODULE_P33, 9);

//        ids=txMsg.data[0] & 0xFFFFFF;
//        if(ids==0x345678) IfxPort_togglePin(&MODULE_P33, 9);

        //3个节点对应的ISO 11992的地址，按牵引车-挂车1-挂车2的顺序，写在数据域的低6Bytes。
        //如现在的情况下，报文ID为0x12345678的数据域内容为0x0020c8c0，0x00000000
        ids=txMsg.data[0];
        writeDataFlash(ids);
    }
    int getid;
    getid = MEM(DFLASH_STARTING_ADDRESS);
    //以下测试通过
//    if(getid==0x0020c8c0)
//    {
//        IfxPort_togglePin(&MODULE_P33, 9);
//    }
//    else
//    {
//        IfxPort_togglePin(&MODULE_P33, 8);
//    }
    int id1,id2,id3;
    id3 = getid & 0xFF;
    id2 = getid>>8 & 0xFF;
    id1 = getid>>16 & 0xFF;
    if(id1 == 0x20 && id2 == 0xc8 && id3 == 0xc0) IfxPort_togglePin(&MODULE_P33, 9);
}


#define WAIT_TIME 500   /* Wait time constant in milliseconds   */

//发送中断处理函数 翻转LED1
void canIsrTxHandler(void)
{
    IfxPort_togglePin(&MODULE_P33, 8);
}

//接收中断处理函数 先翻转LED2
void canIsrRxHandler(void)
{
    IfxPort_togglePin(&MODULE_P33, 9);
    IfxMultican_Status readStatus;      //读CAN状态位

    IfxMultican_Message rxMsg;          //定义数据帧格式 含ID 数据长度 数据

    /* Read the received CAN message and store the status of the operation */
    readStatus = IfxMultican_Can_MsgObj_readMessage(&canRcvMsgObj, &rxMsg);     //读取收到的CAN消息并存储操作状态

    /* If no new data has been received, report an error */
    if( !( readStatus & IfxMultican_Status_newData ) )
    {
        while(1)
        {
        }
    }

    /* If new data has been received but with one message lost, report an error */
    if( readStatus == IfxMultican_Status_newDataButOneLost )
    {
        while(1)
        {
        }
    }

    CAN_SendSingle(0x12345200, rxMsg.data[0], rxMsg.data[1]);        //将接收到的数据赋给ID为0x12345200的数据帧并发送

}

void CanApp_init(void)
{
    // create configuration
    IfxMultican_Can_Config canConfig;
    IfxMultican_Can_initModuleConfig(&canConfig, &MODULE_CAN);
    // initialize interrupt priority
    canConfig.nodePointer[TX_INTERRUPT_SRC_ID].priority = ISR_PRIORITY_CAN_TX;
    canConfig.nodePointer[RX_INTERRUPT_SRC_ID].priority = ISR_PRIORITY_CAN_RX;      //定义中断等级
    canConfig.nodePointer[RX_INTERRUPT_SRC_ID_2].priority = ISR_PRIORITY_CAN_RX_2;      //定义中断等级
    // initialize module
    IfxMultican_Can_initModule(&can, &canConfig);

    // create CAN node config
    IfxMultican_Can_NodeConfig canNodeConfig;
    IfxMultican_Can_Node_initConfig(&canNodeConfig, &can);
    canNodeConfig.baudrate = 125000; //
    canNodeConfig.nodeId = IfxMultican_NodeId_0;
    canNodeConfig.rxPin = &IfxMultican_RXD0B_P20_7_IN;      //初始化管脚
    canNodeConfig.txPin = &IfxMultican_TXD0_P20_8_OUT;
    IfxMultican_Can_Node_init(&canSrcNode, &canNodeConfig);

    // create message object config
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &canSrcNode);
    // assigned message object:
    canMsgObjConfig.msgObjId = 0;
    canMsgObjConfig.frame = IfxMultican_Frame_transmit;
    canMsgObjConfig.control.messageLen = IfxMultican_DataLengthCode_8;
    canMsgObjConfig.control.extendedFrame = TRUE;
    canMsgObjConfig.txInterrupt.enabled = TRUE;     //使能发送中断
    canMsgObjConfig.txInterrupt.srcId = TX_INTERRUPT_SRC_ID;    //定义中断源
    // initialize receive message object
    IfxMultican_Can_MsgObj_init(&canSrcMsgObj, &canMsgObjConfig);

    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &canSrcNode);
    canMsgObjConfig.msgObjId = 1;
    canMsgObjConfig.messageId = 0x12345100;      //定义触发中断的ID
    canMsgObjConfig.acceptanceMask = 0xFFFFFFFF;
    //canMsgObjConfig.acceptanceMask = 0x7FFFFFFFUL;  //指定接收掩码。这是滤波了嘛？
    canMsgObjConfig.frame = IfxMultican_Frame_receive;
    canMsgObjConfig.control.messageLen = IfxMultican_DataLengthCode_8;
    canMsgObjConfig.control.extendedFrame = TRUE;
    canMsgObjConfig.rxInterrupt.enabled = TRUE;     //使能接收中断
    canMsgObjConfig.rxInterrupt.srcId = RX_INTERRUPT_SRC_ID;    //定义中断源
    // initialize message object
    IfxMultican_Can_MsgObj_init(&canRcvMsgObj, &canMsgObjConfig);

    //配置节点ID使用的MO
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &canSrcNode);
    canMsgObjConfig.msgObjId = 2;
    canMsgObjConfig.messageId = 0x12345678;      //定义触发中断的ID
    canMsgObjConfig.acceptanceMask = 0xFFFFFFFF;
    //canMsgObjConfig.acceptanceMask = 0x7FFFFFFFUL;  //指定接收掩码。这是滤波了嘛？
    canMsgObjConfig.frame = IfxMultican_Frame_receive;
    canMsgObjConfig.control.messageLen = IfxMultican_DataLengthCode_8;
    canMsgObjConfig.control.extendedFrame = TRUE;
    canMsgObjConfig.rxInterrupt.enabled = TRUE;     //使能接收中断
    canMsgObjConfig.rxInterrupt.srcId = RX_INTERRUPT_SRC_ID_2;    //定义中断源
    // initialize message object
    IfxMultican_Can_MsgObj_init(&canRcvMsgObj2, &canMsgObjConfig);
}

//CAN发送函数
void CAN_SendSingle(uint32 id, uint32 high, uint32 low)
{
    // Initialize the message structure
    IfxMultican_Message txMsg;
    IfxMultican_Message_init(&txMsg, id, low, high, IfxMultican_DataLengthCode_8);

    // Transmit Data
    while( IfxMultican_Can_MsgObj_sendMessage(&canSrcMsgObj, &txMsg) == IfxMultican_Status_notSentBusy );

}

int core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    initTime();
    IfxPort_setPinMode(&MODULE_P33, 8, IfxPort_Mode_outputPushPullGeneral);

    IfxPort_setPinMode(&MODULE_P33, 9, IfxPort_Mode_outputPushPullGeneral);

    IfxPort_setPinHigh(&MODULE_P33, 8);
    IfxPort_setPinLow(&MODULE_P33, 9);


    CanApp_init();
    while(1)
    {
       CAN_SendSingle(0x01234567,0,1);   //低位 高位
//
       waitTime(IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME));    /* Wait 500 milliseconds            */
       IfxPort_togglePin(&MODULE_P33, 8);
//       int  i=0;
//       while(i<100000) i++;
//       i=0;

       /*CAN_SendSingle(0x200,0xffffffff,1);   //低位 高位
       int  j=0;
       while(j<100000000) j++;
       j=0;*/

       /*延时翻转电平
        * int  i=0;
       while(i<100000000) i++;
       i=0;
       IfxPort_togglePin(&MODULE_P33, 8);*/

    }
    return (1);
}
